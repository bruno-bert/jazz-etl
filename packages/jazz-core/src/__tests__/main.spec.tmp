import { Application } from "@core/Application";

import {
  SUCCESS_MESSAGE,
  ERROR_SOURCEDATA_NOT_OVERRIDEN
} from "@config/Messages";

import { Pipeline } from "@core/Pipeline";
import { Task } from "@core/Task";
import {
  ResultData,
  SourceData,
  IsApplication,
  SourceDataIdentifier
} from "../types/core";
import { MockTask } from "./mocks/MockTask";
import { MockPlugin } from "./mocks/MockPlugin";

describe("main", () => {
  let app: IsApplication;
  beforeEach(() => {
    app = Application.getInstance();
  });
  afterEach(() => {
    app.detach();
  });

  it("Should return a callback with a success message", () => {
    app.start((err: string | null, result: string | null) => {
      expect(err).toBe(null);
      expect(result).toEqual(SUCCESS_MESSAGE);
    });
  });

  it("Should add a pipeline to the app", () => {
    const pipeline = new Pipeline();
    let task = new (class MyTask extends Task {
      execute(): Promise<ResultData> {
        return new Promise<ResultData>((resolve, reject) => {
          try {
            resolve({ data: "some data" });
          } catch (err) {
            reject(err);
          }
        });
      }
    })({ id: "1" });

    pipeline.addTask(task);
    app.addPipeline(pipeline);
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines.length).toBeGreaterThan(0);
    });
  });

  it("Should avoid tasks with same id in pipeline", () => {
    const pipeline = new Pipeline();
    let task1 = new MockTask({ id: "1" });
    let task2 = new MockTask({ id: "1" });
    pipeline.addTask(task1);
    pipeline.addTask(task2);
    app.addPipeline(pipeline);
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines[0].tasks.length).toEqual(1);
    });
  });

  it("Should add 2 tasks in pipeline", () => {
    const pipeline = new Pipeline();
    let task1 = new MockTask({ id: "1" });
    let task2 = new MockTask({ id: "2" });

    pipeline.addTask(task1);
    pipeline.addTask(task2);
    app.addPipeline(pipeline);
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines[0].tasks.length).toEqual(2);
    });
  });

  it("Should add entire plugin pipeline into main pipeline", () => {
    const plugin = new MockPlugin();
    app.addPipeline(plugin.getPipeline());
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines.length).toEqual(1);
      expect(app.pipelines[0].tasks.length).toEqual(4);
    });
  });

  it("Should return all task Ids from certain plugin", () => {
    const plugin = new MockPlugin();
    const taskIds = plugin.getTaskIds();
    expect(taskIds?.length).toEqual(4);
  });

  it("Should add selected tasks from plugin pipeline into main pipeline", () => {
    const plugin = new MockPlugin();

    const pipeline = plugin.getPipelineByTaskIds(["1", "2"]);

    if (pipeline) app.addPipeline(pipeline);

    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines.length).toEqual(1);
      expect(app.pipelines[0].tasks.length).toEqual(2);
    });
  });

  it("Should run a task standalone and return an error in case task has no sourceTaskId and getSourceData is not overriden", async () => {
    let task = new MockTask({ id: "teste" });

    await expect(task.run()).rejects.toMatch(ERROR_SOURCEDATA_NOT_OVERRIDEN);
  });

  it("Should run a task standalone which has method getSourceData overriden", async () => {
    const testResult = { message: "test" };
    let task = new (class OtherTask extends MockTask {
      getSourceData() {
        return new Promise<SourceData>((resolve, reject) => {
          resolve(testResult);
        });
      }
    })({ id: "1" });

    await expect(task.run()).resolves.toEqual(testResult);
  });

  it("Should not run a skipped task and return null", async () => {
    const testResult = { message: "test" };
    let task = new (class OtherTask extends MockTask {
      getSourceData() {
        return new Promise<SourceData>((resolve, reject) => {
          resolve(testResult);
        });
      }
    })({ id: "1" });
    task.setSkip(true);
    await expect(task.run()).resolves.toEqual(null);
  });

  it("Should allow create task without any configuration - automatic id", async () => {
    const pipeline = new Pipeline();
    let task1 = new MockTask();
    let task2 = new MockTask();

    pipeline.addTask(task1);
    pipeline.addTask(task2);

    app.addPipeline(pipeline);
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines[0].tasks.length).toEqual(2);
    });
  });

  it("Should avoid duplicated task - automatic id", async () => {
    const pipeline = new Pipeline();
    let task = new MockTask();

    pipeline.addTask(task);
    pipeline.addTask(task);

    app.addPipeline(pipeline);
    app.start((err: string | null, result: string | null) => {
      expect(app.pipelines[0].tasks.length).toEqual(1);
    });
  });

  it("Should run task standalone and wait result using async/await", async () => {
    let testResult = { message: "this has the data" };
    let task = new (class MyTask extends Task {
      execute(): Promise<ResultData> {
        return new Promise<ResultData>((resolve, reject) => {
          try {
            resolve(testResult);
          } catch (err) {
            reject(err);
          }
        });
      }
    })();
    const result = await task.run();
    expect(result).toBe(testResult);
  });
});
